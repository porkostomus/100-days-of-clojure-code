* 100 Days of Clojure Code



** Day 31: October 15, 2018

*** Clojure Algorithm performance tests

A couple different motivations for this.
One is just to practice making graphs with Incanter,
so I thought, "What would be something useful I could measure?"
And more obviously, to learn stuff. Moar smart stuff...

I was a high-school dropout who followed a music career,
only to finally get my GED at age 30 and go to community college.
Point being that I never learned any math. None, besides very basic algebra.

I find this a rather embarrassing fact, that I'm trying to teach myself programming when I don't know math.
There's just something not right there, especially in a programming paradigm so data-centered.
This is why a big chunk of my time must go to madly trying to fill in these major gaps in my education.

This ought to involve both a "bottom-up" approach of learning the fundamentals in some logical order,
as well as a "top-down" approach of finding what will be most relevant in my field and attacking that.

This is what I feel to be a nice synthesis of the two approaches.
So where to start?

**** Time complexity: Order of growth of common algorithms

My idea is to select an algorithm with a known order of growth,
implement it in Clojure, and chart its execution time with Incanter.

| Time Complexity | Notation   | Algorithm                                 |
|-----------------+------------+-------------------------------------------|
| Constant time   | O(1)       | Lookup table                              |
| Logarithmic     | O(log n)   | Binary search                             |
| Linear          | O(n)       | Find item in unsorted list                |
| Linearithmic    | O(n log n) | Merge sort                                |
| Quadratic       | O(n^2)     | Bubble sort                               |
| Polynomial      | O(n^c)     | Tree-adjoining grammar parsing            |
| Exponential     | O(c^n)     | Travelling salesman - dynamic programming |
| Factorial       | O(n!)      | Travelling salesman - brute force         |

I guess we could start with an easy one, like linear time.
Find an item in a unsorted list. So we'll take sets of integers of different sizes and shuffle them:

#+BEGIN_SRC clojure
(shuffle (range 10))
#+END_SRC

#+RESULTS:
| 1 | 8 | 7 | 0 | 3 | 5 | 6 | 4 | 9 | 2 |

So what do we even do here?
The first thing I can think of would be to set up a recursive loop calling nth on each item,
and returning the index of the first one that matches, say 0.

That would go something like this:

#+BEGIN_SRC clojure
    (loop [n 0 l (shuffle (range 10))]
      (if (zero? (nth l n))
        [l n]
        (recur (inc n) l)))
#+END_SRC

#+RESULTS:
| (5 0 1 4 9 8 3 6 2 7) | 1 |

Alright, so that seems to work, so let's try passing it to ~time~ at different lengths.
Keep in mind though that I probably need to do something in order to isolate the operation that I'm trying to test.

|  Digits |       msecs |
|---------+-------------|
|      10 |    0.357463 |
|     100 |    0.419771 |
|    1000 |    4.275288 |
|   10000 |   12.237828 |
|  100000 |   48.569876 |
| 1000000 | 3902.479665 |

OK that looks like some halfway decent starting data.
Let's make a chart of that:

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 1000000])
  (def time [0.357463 0.419771 4.275288 12.237828 48.569876 3902.479665])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "linear-xy-line.png")
#+end_src

#+CAPTION: Find item in list
#+NAME: fig:xy-line
[[./linear-xy-line.png]]

As we can see it looks like sort of linear growth, but something funny happens at around 100000 digits.

A couple of issues I can think of:

1. I'm conflating the time it takes to shuffle it with the search itself.
2. I should be measuring the worst-case scenario, instead of a "random scenario" that I'm doing here.

To address this, I'll define the lists ahead of time, and reverse them instead of shuffling them:

#+BEGIN_SRC clojure
(def list-10 (reverse (range 10)))
(def list-100 (reverse (range 100)))
(def list-1000 (reverse (range 1000)))
(def list-10000 (reverse (range 10000)))
(def list-100000 (reverse (range 100000)))
(def list-1000000 (reverse (range 1000000)))

(time (loop [n 0 l list-10]
      (if (zero? (nth l n))
        [l n]
        (recur (inc n) l))))
#+END_SRC

Results:

|  Digits |          msecs |
|---------+----------------|
|      10 |       0.977336 |
|     100 |       2.470361 |
|    1000 |      19.616862 |
|   10000 |      386.23202 |
|  100000 |   83758.810631 |
| 1000000 | 8412869.398572 |

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 1000000])
  (def time [0.977336 2.470361 19.616862 386.23202 83758.810631 8412869.398572])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "linear-xy-line-2.png")
#+end_src

#+CAPTION: Find item in list
#+NAME: fig:xy-line
[[./linear-xy-line-2.png]]

It's the exact same curve!


*** pREPL Alpha released in Clojure 1.10

I do know one project that is already using this to check out.
My goal is to use it in my text editor, because it sounds really great:
The simplicity of Socket REPL, but in structured EDN format.
That way you can properly deal with what is a return value, what is printed and what's an error or whatever.

** Day 30: October 14, 2018

Going to turn [[https://github.com/porkostomus/bob][Bob the Text Editor]] into a Clojure editor.
I've been thinking about this for awhile,
and I believe I have a basic plan of attack.

It will begin with syntax highlighting.
Which I think is the least useful feature,
but it makes sense to start there because besides being a useful exercise,
it is the logical first step towards a Clojure-aware editor.
The ability to recognize Clojure forms.

The plan is to use (initially) something really simple,
like Socket REPL or pREPL, but even before that,
I might just do something really silly like...

Send it out to Planck. Ha ha. No, really.

We'll just set up a key binding, like Ctrl+Enter or something,
which will actually be just an "alternative save".
That is, instead of saving the entire file,
it will save only the form preceding the cursor.

Yes, so we're saving the form to a text file.
This is really not much different from a REPL history file,
but is a temporary file that will be overwritten with a single form,
evaluated with planck and the result spit to another file,
which can then be read into a separate "results" buffer!


Let's do an experiment just to test out scripting with [[http://planck-repl.org/][Planck]].

*** Planck

[[http://planck-repl.org/guide-all.html][Here]] is the full user guide.



*** Plan of action

First, let's just take a look at the existing methods of Clojure code analysis and presentation.

Of particular interest is Rebel Readline,
because it provides such useful features in an editor-agnostic way.

*** Syntax highlighting

As an introduction, let's take a look at the way it is done for the C language.

Fortunately there is a great [[https://viewsourcecode.org/snaptoken/kilo/07.syntaxHighlighting.html][guide by snaptoken]] available.

First we can do something very simple, like turn all the numbers red.

Here's our ~editorDrawRows~ function:

#+BEGIN_SRC c
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Bob, the text editor");
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, " ", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, " ", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].render[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    abAppend(ab, "\r\n", 2);
  }
}

#+END_SRC

[[./2018-10-14-233606_1366x768_scrot.png]]

Now instead of feeding the substring of ~render~ into ~abAppend()~ with this line:

#+BEGIN_SRC c
abAppend(ab, &E.row[filerow].render[E.coloff], len);
#+END_SRC

Rather, we will loop through the characters and use ~isdigit()~ on each one to test if it is a digit character.
If it is, we precede it with the <esc>[31m escape sequence and follow it by the <esc>[39m sequence:

#+BEGIN_SRC c
char *c = &E.row[filerow].render[E.coloff];
      int j;
      for (j = 0; j < len; j++) {
        if (isdigit(c[j])) {
          abAppend(ab, "\x1b[31m", 5);
          abAppend(ab, &c[j], 1);
          abAppend(ab, "\x1b[39m", 5);
        } else {
          abAppend(ab, &c[j], 1);
        }
      }
#+END_SRC

[[./2018-10-14-233941_1366x768_scrot.png]]

** Day 29: October 13, 2018

*** More minesweeper business

Ah... so now that we've got this sweet live-coding journal set up,
we can get back to the thing I was trying to do in the first place.
What was it?

Yes, my Minesweeper board:

#+BEGIN_SRC clojure
  (def board-width 6)
  (def board-height 6)

  (for [x (range board-width)
        y (range board-height)]
        [x y])
#+END_SRC

#+RESULTS:
: #'user/board-width#'user/board-height
([0 0] [0 1] [0 2] [0 3] [0 4] [0 5]
 [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] 
 [2 0] [2 1] [2 2] [2 3] [2 4] [2 5]
 [3 0] [3 1] [3 2] [3 3] [3 4] [3 5]
 [4 0] [4 1] [4 2] [4 3] [4 4] [4 5]
 [5 0] [5 1] [5 2] [5 3] [5 4] [5 5])

It totally works! You just have to have a REPL going. Cider-jack-in.


*** Hey wait, let's check out Incanter some more!

I was watching a talk recently about this library and how it's still working great.
Who was that? I need to find that again.

Anyway, now that I've stepped into such a tank I might as well kick the tires and see what kind of stuff it can do.

So what is [[https://github.com/incanter/incanter][Incanter]] anyway?
A Clojure-based, R-like statistical computing and graphics environment for the JVM.

That sounds great. Especially all that smartypants statistical computing stuff.

If I were the type of person who dabbled in the likes of whatnot stuff, what would I do?



** Day 28: October 12, 2018

Great! It works, let's just make this the new log now.

And I'll upload the new .spacemacs too. Done.

#+begin_src clojure :results silent
  (+ 1 4)
#+end_src

#+begin_src clojure :results value
  [ 1 2 3 4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

#+begin_src clojure :results value
  (def small-map {:a 2 :b 4 :c 8})
  (:b small-map)
#+end_src

#+RESULTS:
: #'user/small-map4

This code will demonstrate the creation of a basic x-y line plot using the Incanter xy-plot function.

#+begin_src clojure
  (use '(incanter core charts pdf))
  ;;; Create the x and y data:
  (def x-data [0.0 1.0 2.0 3.0 4.0 5.0])
  (def y-data [2.3 9.0 2.6 3.1 8.1 4.5])
  (def xy-line (xy-plot x-data y-data))
  (view xy-line)
  (save xy-line "incanter-xy-line.png")
#+end_src

#+CAPTION: A basic x-y line plot
#+NAME: fig:xy-line
[[./incanter-xy-line.png]]


Try an example: sample 1,000 values from a standard-normal distribution and view a histogram: 

#+BEGIN_SRC clojure
(use '(incanter core stats charts))
(view (histogram (sample-normal 1000)))
#+END_SRC

#+RESULTS:
: nil#object[org.jfree.chart.ChartFrame 0xc83b84f "org.jfree.chart.ChartFrame[frame1,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,2,25,496x368,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

Try another simple example, a plot of the sine function over the range -10 to 10:

#+BEGIN_SRC clojure
(view (function-plot sin -10 10))
#+END_SRC

#+RESULTS:
: #object[org.jfree.chart.ChartFrame 0xb0e4542 "org.jfree.chart.ChartFrame[frame2,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,5,25,490x370,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

