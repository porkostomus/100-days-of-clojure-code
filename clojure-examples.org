* 100 Days of Clojure Code

** Day 32: October 16, 2018

*** Syntax highlighting

Wikipedia article on [[https://en.wikipedia.org/wiki/ANSI_escape_code][ANSI escape codes]]

Here's our existing ~erow~ struct:

#+BEGIN_SRC c
typedef struct erow {
  int size;
  int rsize;
  char *chars;
  char *render;
} erow;
#+END_SRC

We're going to add an array of unsigned char values (integers in the range of 0 to 255)
to store the highlighting data, called ~hl~:

#+BEGIN_SRC c
unsigned char *hl;
#+END_SRC

Now add it to our ~editorInsertRow~ function:

#+BEGIN_SRC c
void editorInsertRow(int at, char *s, size_t len) {
  if (at < 0 || at > E.numrows) return;
  E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));
  memmove(&E.row[at + 1], &E.row[at], sizeof(erow) * (E.numrows - at));
  E.row[at].size = len;
  E.row[at].chars = malloc(len + 1);
  memcpy(E.row[at].chars, s, len);
  E.row[at].chars[len] = '\0';
  E.row[at].rsize = 0;
  E.row[at].render = NULL;
  E.row[at].hl = NULL;
  editorUpdateRow(&E.row[at]);
  E.numrows++;
  E.dirty++;
}
#+END_SRC

And also here:

#+BEGIN_SRC c
void editorFreeRow(erow *row) {
  free(row->render);
  free(row->chars);
  free(row->hl);
}
#+END_SRC

Each value in the array will correspond to a character in render,
and will tell you whether that character is part of a string, or a comment, or a number, and so on.
Let’s create an enum containing the possible values that the hl array can contain:

#+BEGIN_SRC c
enum editorHighlight {
  HL_NORMAL = 0,
  HL_NUMBER
};
#+END_SRC

*** Syntax highlighting in Clojure

Right now I'm in the spacemacs cyberpunk theme.
Let's see how it colors it:

#+BEGIN_SRC clojure
(defn myfun [x]
  (str "string" (:key (inc x)))

(defn -main []
  (loop [n 1]
    (if (every? true? (evaluate (ans n)))
      (recur (inc n))
(+ 
      (recur n))))
#+END_SRC

Let's see how Rebel Readline does it.

~defn~, ~if~, ~loop~, ~recur~, ~try~, ~catch~ etc are also blue, then all function names are yellow.
A dark yellow, anyway. Then keywords are a pale yellow.

So we're gonna need some sort of lookup table with words in it.

#+BEGIN_SRC c
int editorSyntaxToColor(int hl) {
  switch (hl) {
    case HL_COMMENT: return 36;
    case HL_KEYWORD1: return 33;
    case HL_KEYWORD2: return 32;
    case HL_STRING: return 35;
    case HL_NUMBER: return 31;
    case HL_MATCH: return 34;
    default: return 37;
  }
}
#+END_SRC

We will use an in_string variable to keep track of whether we are currently inside a string.
If we are, then we’ll keep highlighting the current character as a string until we hit the closing quote.

#+BEGIN_SRC c
void editorUpdateSyntax(erow *row) {
  row->hl = realloc(row->hl, row->rsize);
  memset(row->hl, HL_NORMAL, row->rsize);
  if (E.syntax == NULL) return;
  int prev_sep = 1;
  int in_string = 0;
  int i = 0;
  while (i < row->rsize) {
    char c = row->render[i];
    unsigned char prev_hl = (i > 0) ? row->hl[i - 1] : HL_NORMAL;
    if (E.syntax->flags & HL_HIGHLIGHT_STRINGS) {
      if (in_string) {
        row->hl[i] = HL_STRING;
        if (c == '\\' && i + 1 < row->rsize) {
          row->hl[i + 1] = HL_STRING;
          i += 2;
          continue;
        }
        if (c == in_string) in_string = 0;
        i++;
        prev_sep = 1;
        continue;
      } else {
        if (c == '"' || c == '\'') {
          in_string = c;
          row->hl[i] = HL_STRING;
          i++;
          continue;
        }
      }
    }
    if (E.syntax->flags & HL_HIGHLIGHT_NUMBERS) {
      if ((isdigit(c) && (prev_sep || prev_hl == HL_NUMBER)) ||
          (c == '.' && prev_hl == HL_NUMBER)) {
        row->hl[i] = HL_NUMBER;
        i++;
        prev_sep = 0;
        continue;
      }
    }
    prev_sep = is_separator(c);
    i++;
  }
}
#+END_SRC

Now let’s turn to highlighting keywords.
We’re going to allow languages to specify two types of keywords that will be highlighted in different colors.
(In C, we’ll highlight actual keywords in one color and common type names in the other color.)

#+BEGIN_SRC c
enum editorHighlight {
  HL_NORMAL = 0,
  HL_COMMENT,
  HL_KEYWORD1,
  HL_KEYWORD2,
  HL_STRING,
  HL_NUMBER,
  HL_MATCH
};
#+END_SRC

The two colors we’ll use for keywords are yellow (33) and green (32).

Let’s add a keywords array to the ~editorSyntax~ struct.
This will be a NULL-terminated array of strings, each string containing a keyword.
To differentiate between the two types of keywords,
we’ll terminate the second type of keywords with a pipe (|) character.

#+BEGIN_SRC c
struct editorSyntax {
  char *filetype;
  char **filematch;
  char **keywords;
  char *singleline_comment_start;
  int flags;
};

char *C_HL_keywords[] = {
  "switch", "if", "while", "for", "break", "continue", "return", "else",
  "struct", "union", "typedef", "static", "enum", "class", "case",
  "int|", "long|", "double|", "float|", "char|", "unsigned|", "signed|",
  "void|", NULL
};
#+END_SRC

So what I'll do here is make one for Clojure:

#+BEGIN_SRC c
char *Clj_HL_keywords[] = {
  "fn", "defn", "defn-", "def", "let", "letfn", "declare", "ns", "if", "if-not",
  "when", "when-not", "when-let", "when-first", "if-let", "cond", "condp", "do",
  "case", "when-some", "if-some", "and", "or", "for", "doseq", "dotimes", "while",
  "->", "->>", "as->", "cond->", "cond->>", "some->", "some->>", "lazy-cat", "lazy-seq",
  "=|", "==|", "not=|", "not|", "identical?|", "compare|", "map|", "map-indexed|", "reduce|",
  "true?|", "false?|", "instance?|", "nil?|", "some|", "some?|", "+|", "-|", "*|", "/|",
  "quot|", "rem|", "mod|", "inc|", "dec|", "max|", "min|", "<|", ">|", "<=|", ">=|",
  "int|", "zero?|", "pos?|", "neg?|", "even?|", "odd?|", "number?|", "integer?|",
  "rand|", "rand-int|", "atom|", "deref|", "swap!|", "reset!|", "compare-and-set!|",
  "add-watch|", "remove-watch|", "set-validator!|", "get-validator|", "identity|",
  "constantly|", "comp|", "complement|", "partial|", "juxt|", "memoize|", "fnil|",
  "every-pred|", "some-fn|", "apply|", "fn?|", "ifn?|", "str|", "name|", "count|",
  "get|", "subs|", "replace|", "reverse|", "re-find|", "re-seq|", "re-matches",
  "re-pattern|", "char|", "string?|", "count|", "empty|", "not-empty|", "into|",
  "conj|", "distict|", "distinct?|", "empty?|", "every?|", "not-every?|", "some|",
  "not-any?|", "sequential?|", "associative?|", "sorted?|", "counted?|", "reversible?|",
  "coll?|", "list?|", "vector?|", "set?|", "map?|", "seq?|", "vec|", "vector|", "nth|",
  "get|", "peek|", "assoc|", "pop|", "subvec|", "rseq|", "mapv|", "filterv|", "reduce-kv|",
  "hash-map|", "array-map|", "zipmap|", "sorted-map|", "sorted-map-by|", "frequencies|",
  "group-by|", "get-in|", "contains?|", "find|", "key|", "keys|", "val|", "vals|",
  "assoc-in|", "dissoc|", "merge|", "merge-with|", "select-keys|", "update-in|",
  "subseq|", "rsubseq|", "list|", "list*|", "first|", "rest|", "cons|", "set|", "hash-set|",
  "sorted-set|", "sorted-set-by|", "disj|", "filter|", "remove|",   NULL
}; 
#+END_SRC


** Day 31: October 15, 2018

*** Clojure Algorithm performance tests

A couple different motivations for this.
One is just to practice making graphs with Incanter,
so I thought, "What would be something useful I could measure?"
And more obviously, to learn stuff. Moar smart stuff...

I was a high-school dropout who followed a music career,
only to finally get my GED at age 30 and go to community college.
Point being that I never learned any math. None, besides very basic algebra.

I find this a rather embarrassing fact, that I'm trying to teach myself programming when I don't know math.
There's just something not right there, especially in a programming paradigm so data-centered.
This is why a big chunk of my time must go to madly trying to fill in these major gaps in my education.

This ought to involve both a "bottom-up" approach of learning the fundamentals in some logical order,
as well as a "top-down" approach of finding what will be most relevant in my field and attacking that.

This is what I feel to be a nice synthesis of the two approaches.
So where to start?

**** Time complexity: Order of growth of common algorithms

My idea is to select an algorithm with a known order of growth,
implement it in Clojure, and chart its execution time with Incanter.

| Time Complexity | Notation   | Algorithm                                 |
|-----------------+------------+-------------------------------------------|
| Constant time   | O(1)       | Lookup table                              |
| Logarithmic     | O(log n)   | Binary search                             |
| Linear          | O(n)       | Find item in unsorted list                |
| Linearithmic    | O(n log n) | Merge sort                                |
| Quadratic       | O(n^2)     | Bubble sort                               |
| Polynomial      | O(n^c)     | Tree-adjoining grammar parsing            |
| Exponential     | O(c^n)     | Travelling salesman - dynamic programming |
| Factorial       | O(n!)      | Travelling salesman - brute force         |

***** Linear time - find item in list

I guess we could start with an easy one, like linear time.
Find an item in a unsorted list. So we'll take sets of integers of different sizes and shuffle them:

#+BEGIN_SRC clojure
(shuffle (range 10))
#+END_SRC

#+RESULTS:
| 1 | 8 | 7 | 0 | 3 | 5 | 6 | 4 | 9 | 2 |

So what do we even do here?
The first thing I can think of would be to set up a recursive loop calling nth on each item,
and returning the index of the first one that matches, say 0.

That would go something like this:

#+BEGIN_SRC clojure
    (loop [n 0 l (shuffle (range 10))]
      (if (zero? (nth l n))
        [l n]
        (recur (inc n) l)))
#+END_SRC

#+RESULTS:
| (5 0 1 4 9 8 3 6 2 7) | 1 |

Alright, so that seems to work, so let's try passing it to ~time~ at different lengths.
Keep in mind though that I probably need to do something in order to isolate the operation that I'm trying to test.

|  Digits |       msecs |
|---------+-------------|
|      10 |    0.357463 |
|     100 |    0.419771 |
|    1000 |    4.275288 |
|   10000 |   12.237828 |
|  100000 |   48.569876 |
| 1000000 | 3902.479665 |

OK that looks like some halfway decent starting data.
Let's make a chart of that:

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 1000000])
  (def time [0.357463 0.419771 4.275288 12.237828 48.569876 3902.479665])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "linear-xy-line.png")
#+end_src

#+CAPTION: Find item in list
#+NAME: fig:xy-line
[[./linear-xy-line.png]]

As we can see it looks like sort of linear growth, but something funny happens at around 100000 digits.

A couple of issues I can think of:

1. I'm conflating the time it takes to shuffle it with the search itself.
2. I should be measuring the worst-case scenario, instead of a "random scenario" that I'm doing here.

To address this, I'll define the lists ahead of time, and reverse them instead of shuffling them:

#+BEGIN_SRC clojure
(def list-10 (reverse (range 10)))
(def list-100 (reverse (range 100)))
(def list-1000 (reverse (range 1000)))
(def list-10000 (reverse (range 10000)))
(def list-100000 (reverse (range 100000)))
(def list-1000000 (reverse (range 1000000)))

(time (loop [n 0 l list-10]
      (if (zero? (nth l n))
        [l n]
        (recur (inc n) l))))
#+END_SRC

#+RESULTS:
: #'user/list-10#'user/list-100#'user/list-1000#'user/list-10000#'user/list-100000#'user/list-1000000class java.lang.IllegalArgumentExceptionclass java.lang.IllegalArgumentExceptionIllegalArgumentException Key must be integer  clojure.lang.APersistentVector.invoke (APersistentVector.java:294)

Results:

|  Digits |          msecs |
|---------+----------------|
|      10 |       0.977336 |
|     100 |       2.470361 |
|    1000 |      19.616862 |
|   10000 |      386.23202 |
|  100000 |   83758.810631 |
| 1000000 | 8412869.398572 |

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 1000000])
  (def time [0.977336 2.470361 19.616862 386.23202 83758.810631 8412869.398572])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "linear-xy-line-2.png")
#+end_src

#+RESULTS:
: nil#'user/digits#'user/time#'user/xy-line#object[org.jfree.chart.ChartFrame 0x63574932 "org.jfree.chart.ChartFrame[frame1,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,5,25,490x370,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]nil

#+CAPTION: Find item in list
#+NAME: fig:xy-line
[[./linear-xy-line-2.png]]

It's the exact same curve!




***** Quadratic time - bubble sort

#+BEGIN_SRC clojure
(defn- bubble [ys x]
  (if-let [y (peek ys)]
    (if (> y x)
      (conj (pop ys) x y)
      (conj ys x))
    [x]))

(defn bubble-sort [xs]
  (let [ys (reduce bubble [] xs)]
    (if (= xs ys)
      xs
      (recur ys))))

(bubble-sort list-10)
#+END_SRC

#+RESULTS:
: #'user/bubble#'user/bubble-sort[0 1 2 3 4 5 6 7 8 9]

We can probably reuse the above collections, since they are maximally un-sorted already.

| Digits |          msecs |
|--------+----------------|
|     10 |         2.5688 |
|    100 |      58.625717 |
|   1000 |    2079.451468 |
|  10000 |   27072.646706 |
| 100000 | 2189811.479082 |
|        |                |

I'm afraid to try a million.

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 100000])
  (def time [2.5688 58.625717 2079.451468 27072.646706 2189811.479082])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "bubble.png")
#+end_src

#+RESULTS:
: nil#'user/digits#'user/time#'user/xy-line#object[org.jfree.chart.ChartFrame 0xb1d9f81 "org.jfree.chart.ChartFrame[frame3,0,0,500x400,invalid,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,2,25,496x368,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]nil


#+CAPTION: Bubble Sort
#+NAME: fig:xy-line
[[./bubble.png]]

What? It's that same chart again...

Is somebody messing with me?

What am I doing wrong?

Let's try a more efficient one, like merge sort.



***** Linearithmic - merge sort

#+BEGIN_SRC clojure
(defn merge-sort [coll]
  (if (or (empty? coll) (= 1 (count coll)))
    coll
    (let [[l1 l2] (split-at (/ (count coll) 2) coll)]
      (loop [r [] l1 (merge-sort l1) l2 (merge-sort l2)]
        (cond (empty? l1) (into r l2)
              (empty? l2) (into r l1)
              :else (if (> 0 (compare (first l1) (first l2)))
                      (recur (conj r (first l1)) (rest l1) l2)
                      (recur (conj r (first l2)) l1 (rest l2))))))))

(def list-10 (reverse (range 10)))

(merge-sort list-10)
#+END_SRC

#+RESULTS:
: #'user/merge-sort#'user/list-10[0 1 2 3 4 5 6 7 8 9]

| Digits |       msecs |
|--------+-------------|
|     10 |    0.161835 |
|    100 |    0.722971 |
|   1000 |    7.229004 |
|  10000 |  101.244589 |
| 100000 | 1378.267681 |

#+begin_src clojure
  (use '(incanter core charts))
  ;;; Create the x and y data:
  (def digits [10 100 1000 10000 100000 100000])
  (def time [0.161835 0.722971 7.229004 101.244589 1378.267681])
  (def xy-line (xy-plot digits time))
  (view xy-line)
  (save xy-line "merge.png")
#+end_src

#+RESULTS:
: nil#'user/digits#'user/time#'user/xy-line#object[org.jfree.chart.ChartFrame 0x5001ec25 "org.jfree.chart.ChartFrame[frame1,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,5,25,490x370,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]nil


#+CAPTION: Merge Sort
#+NAME: fig:xy-line
[[./merge.png]]


*** pREPL Alpha released in Clojure 1.10

I do know of [[https://github.com/raymcdermott/reptile-body/blob/master/src/reptile/server/socket_repl.clj][one project]] that is already using this to check out.
My goal is to use it in my text editor, because it sounds really great:
The simplicity of Socket REPL, but in structured EDN format.
That way you can properly deal with what is a return value, what is printed and what's an error or whatever.

** Day 30: October 14, 2018

Going to turn [[https://github.com/porkostomus/bob][Bob the Text Editor]] into a Clojure editor.
I've been thinking about this for awhile,
and I believe I have a basic plan of attack.

It will begin with syntax highlighting.
Which I think is the least useful feature,
but it makes sense to start there because besides being a useful exercise,
it is the logical first step towards a Clojure-aware editor.
The ability to recognize Clojure forms.

The plan is to use (initially) something really simple,
like Socket REPL or pREPL, but even before that,
I might just do something really silly like...

Send it out to Planck. Ha ha. No, really.

We'll just set up a key binding, like Ctrl+Enter or something,
which will actually be just an "alternative save".
That is, instead of saving the entire file,
it will save only the form preceding the cursor.

Yes, so we're saving the form to a text file.
This is really not much different from a REPL history file,
but is a temporary file that will be overwritten with a single form,
evaluated with planck and the result spit to another file,
which can then be read into a separate "results" buffer!


Let's do an experiment just to test out scripting with [[http://planck-repl.org/][Planck]].

*** Planck

[[http://planck-repl.org/guide-all.html][Here]] is the full user guide.



*** Plan of action

First, let's just take a look at the existing methods of Clojure code analysis and presentation.

Of particular interest is Rebel Readline,
because it provides such useful features in an editor-agnostic way.

*** Syntax highlighting

As an introduction, let's take a look at the way it is done for the C language.

Fortunately there is a great [[https://viewsourcecode.org/snaptoken/kilo/07.syntaxHighlighting.html][guide by snaptoken]] available.

First we can do something very simple, like turn all the numbers red.

Here's our ~editorDrawRows~ function:

#+BEGIN_SRC c
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Bob, the text editor");
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, " ", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, " ", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].render[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    abAppend(ab, "\r\n", 2);
  }
}

#+END_SRC

[[./2018-10-14-233606_1366x768_scrot.png]]

Now instead of feeding the substring of ~render~ into ~abAppend()~ with this line:

#+BEGIN_SRC c
abAppend(ab, &E.row[filerow].render[E.coloff], len);
#+END_SRC

Rather, we will loop through the characters and use ~isdigit()~ on each one to test if it is a digit character.
If it is, we precede it with the <esc>[31m escape sequence and follow it by the <esc>[39m sequence:

#+BEGIN_SRC c
char *c = &E.row[filerow].render[E.coloff];
      int j;
      for (j = 0; j < len; j++) {
        if (isdigit(c[j])) {
          abAppend(ab, "\x1b[31m", 5);
          abAppend(ab, &c[j], 1);
          abAppend(ab, "\x1b[39m", 5);
        } else {
          abAppend(ab, &c[j], 1);
        }
      }
#+END_SRC

[[./2018-10-14-233941_1366x768_scrot.png]]

** Day 29: October 13, 2018

*** More minesweeper business

Ah... so now that we've got this sweet live-coding journal set up,
we can get back to the thing I was trying to do in the first place.
What was it?

Yes, my Minesweeper board:

#+BEGIN_SRC clojure
  (def board-width 6)
  (def board-height 6)

  (for [x (range board-width)
        y (range board-height)]
        [x y])
#+END_SRC

#+RESULTS:
: #'user/board-width#'user/board-height
([0 0] [0 1] [0 2] [0 3] [0 4] [0 5]
 [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] 
 [2 0] [2 1] [2 2] [2 3] [2 4] [2 5]
 [3 0] [3 1] [3 2] [3 3] [3 4] [3 5]
 [4 0] [4 1] [4 2] [4 3] [4 4] [4 5]
 [5 0] [5 1] [5 2] [5 3] [5 4] [5 5])

It totally works! You just have to have a REPL going. Cider-jack-in.


*** Hey wait, let's check out Incanter some more!

I was watching a talk recently about this library and how it's still working great.
Who was that? I need to find that again.

Anyway, now that I've stepped into such a tank I might as well kick the tires and see what kind of stuff it can do.

So what is [[https://github.com/incanter/incanter][Incanter]] anyway?
A Clojure-based, R-like statistical computing and graphics environment for the JVM.

That sounds great. Especially all that smartypants statistical computing stuff.

If I were the type of person who dabbled in the likes of whatnot stuff, what would I do?



** Day 28: October 12, 2018

Great! It works, let's just make this the new log now.

And I'll upload the new .spacemacs too. Done.

#+begin_src clojure :results silent
  (+ 1 4)
#+end_src

#+begin_src clojure :results value
  [ 1 2 3 4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

#+begin_src clojure :results value
  (def small-map {:a 2 :b 4 :c 8})
  (:b small-map)
#+end_src

#+RESULTS:
: #'user/small-map4

This code will demonstrate the creation of a basic x-y line plot using the Incanter xy-plot function.

#+begin_src clojure
  (use '(incanter core charts pdf))
  ;;; Create the x and y data:
  (def x-data [0.0 1.0 2.0 3.0 4.0 5.0])
  (def y-data [2.3 9.0 2.6 3.1 8.1 4.5])
  (def xy-line (xy-plot x-data y-data))
  (view xy-line)
  (save xy-line "incanter-xy-line.png")
#+end_src

#+CAPTION: A basic x-y line plot
#+NAME: fig:xy-line
[[./incanter-xy-line.png]]


Try an example: sample 1,000 values from a standard-normal distribution and view a histogram: 

#+BEGIN_SRC clojure
(use '(incanter core stats charts))
(view (histogram (sample-normal 1000)))
#+END_SRC

#+RESULTS:
: nil#object[org.jfree.chart.ChartFrame 0xc83b84f "org.jfree.chart.ChartFrame[frame1,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,2,25,496x368,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

Try another simple example, a plot of the sine function over the range -10 to 10:

#+BEGIN_SRC clojure
(view (function-plot sin -10 10))
#+END_SRC

#+RESULTS:
: #object[org.jfree.chart.ChartFrame 0xb0e4542 "org.jfree.chart.ChartFrame[frame2,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,5,25,490x370,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

