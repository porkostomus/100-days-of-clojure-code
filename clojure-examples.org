* 100 Days of Clojure Code


** Day 30: October 14, 2018

Going to turn [[https://github.com/porkostomus/bob][Bob the Text Editor]] into a Clojure editor.
I've been thinking about this for awhile,
and I believe I have a basic plan of attack.

It will begin with syntax highlighting.
Which I think is the least useful feature,
but it makes sense to start there because besides being a useful exercise,
it is the logical first step towards a Clojure-aware editor.
The ability to recognize Clojure forms.

The plan is to use (initially) something really simple,
like Socket REPL or pREPL, but even before that,
I might just do something really silly like...

Send it out to Planck. Ha ha. No, really.

*** Plan of action

First, let's just take a look at the existing methods of Clojure code analysis and presentation.

Of particular interest is Rebel Readline,
because it provides such useful features in an editor-agnostic way.

*** Syntax highlighting

As an introduction, let's take a look at the way it is done for the C language.

Fortunately there is a great [[https://viewsourcecode.org/snaptoken/kilo/07.syntaxHighlighting.html][guide by snaptoken]] available.

First we can do something very simple, like turn all the numbers red.

Here's our ~editorDrawRows~ function:

#+BEGIN_SRC c
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Bob, the text editor");
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, " ", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, " ", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      abAppend(ab, &E.row[filerow].render[E.coloff], len);
    }
    abAppend(ab, "\x1b[K", 3);
    abAppend(ab, "\r\n", 2);
  }
}

#+END_SRC

[[./2018-10-14-233606_1366x768_scrot.png]]

Now note the difference here:

#+BEGIN_SRC c
void editorDrawRows(struct abuf *ab) {
  int y;
  for (y = 0; y < E.screenrows; y++) {
    int filerow = y + E.rowoff;
    if (filerow >= E.numrows) {
      if (E.numrows == 0 && y == E.screenrows / 3) {
        char welcome[80];
        int welcomelen = snprintf(welcome, sizeof(welcome),
          "Bob, the Text Editor");
        if (welcomelen > E.screencols) welcomelen = E.screencols;
        int padding = (E.screencols - welcomelen) / 2;
        if (padding) {
          abAppend(ab, "~", 1);
          padding--;
        }
        while (padding--) abAppend(ab, " ", 1);
        abAppend(ab, welcome, welcomelen);
      } else {
        abAppend(ab, "~", 1);
      }
    } else {
      int len = E.row[filerow].rsize - E.coloff;
      if (len < 0) len = 0;
      if (len > E.screencols) len = E.screencols;
      char *c = &E.row[filerow].render[E.coloff];
      int j;
      for (j = 0; j < len; j++) {
        if (isdigit(c[j])) {
          abAppend(ab, "\x1b[31m", 5);
          abAppend(ab, &c[j], 1);
          abAppend(ab, "\x1b[39m", 5);
        } else {
          abAppend(ab, &c[j], 1);
        }
      }
    }
    abAppend(ab, "\x1b[K", 3);
    abAppend(ab, "\r\n", 2);
  }
}
#+END_SRC

[[./2018-10-14-233941_1366x768_scrot.png]]


** Day 29: October 13, 2018

*** More minesweeper business

Ah... so now that we've got this sweet live-coding journal set up,
we can get back to the thing I was trying to do in the first place.
What was it?

Yes, my Minesweeper board:

#+BEGIN_SRC clojure
  (def board-width 6)
  (def board-height 6)

  (for [x (range board-width)
        y (range board-height)]
        [x y])
#+END_SRC

#+RESULTS:
: #'user/board-width#'user/board-height
([0 0] [0 1] [0 2] [0 3] [0 4] [0 5]
 [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] 
 [2 0] [2 1] [2 2] [2 3] [2 4] [2 5]
 [3 0] [3 1] [3 2] [3 3] [3 4] [3 5]
 [4 0] [4 1] [4 2] [4 3] [4 4] [4 5]
 [5 0] [5 1] [5 2] [5 3] [5 4] [5 5])

It totally works! You just have to have a REPL going. Cider-jack-in.


*** Hey wait, let's check out Incanter some more!

I was watching a talk recently about this library and how it's still working great.
Who was that? I need to find that again.

Anyway, now that I've stepped into such a tank I might as well kick the tires and see what kind of stuff it can do.

So what is [[https://github.com/incanter/incanter][Incanter]] anyway?
A Clojure-based, R-like statistical computing and graphics environment for the JVM.

That sounds great. Especially all that smartypants statistical computing stuff.

If I were the type of person who dabbled in the likes of whatnot stuff, what would I do?



** Day 28: October 12, 2018

Great! It works, let's just make this the new log now.

And I'll upload the new .spacemacs too. Done.

#+begin_src clojure :results silent
  (+ 1 4)
#+end_src

#+begin_src clojure :results value
  [ 1 2 3 4]
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

#+begin_src clojure :results value
  (def small-map {:a 2 :b 4 :c 8})
  (:b small-map)
#+end_src

#+RESULTS:
: #'user/small-map4

This code will demonstrate the creation of a basic x-y line plot using the Incanter xy-plot function.

#+begin_src clojure
  (use '(incanter core charts pdf))
  ;;; Create the x and y data:
  (def x-data [0.0 1.0 2.0 3.0 4.0 5.0])
  (def y-data [2.3 9.0 2.6 3.1 8.1 4.5])
  (def xy-line (xy-plot x-data y-data))
  (view xy-line)
  (save xy-line "incanter-xy-line.png")
#+end_src

#+CAPTION: A basic x-y line plot
#+NAME: fig:xy-line
[[./incanter-xy-line.png]]


Try an example: sample 1,000 values from a standard-normal distribution and view a histogram: 

#+BEGIN_SRC clojure
(use '(incanter core stats charts))
(view (histogram (sample-normal 1000)))
#+END_SRC

#+RESULTS:
: nil#object[org.jfree.chart.ChartFrame 0xc83b84f "org.jfree.chart.ChartFrame[frame1,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,2,25,496x368,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

Try another simple example, a plot of the sine function over the range -10 to 10:

#+BEGIN_SRC clojure
(view (function-plot sin -10 10))
#+END_SRC

#+RESULTS:
: #object[org.jfree.chart.ChartFrame 0xb0e4542 "org.jfree.chart.ChartFrame[frame2,0,0,500x400,layout=java.awt.BorderLayout,title=Incanter Plot,resizable,normal,defaultCloseOperation=DISPOSE_ON_CLOSE,rootPane=javax.swing.JRootPane[,5,25,490x370,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]"]

